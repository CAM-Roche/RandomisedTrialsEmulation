#' P99 Weights Function
#' 
#' This function truncate the weights of data at the 1st and 99th percentile
#' @param switch_data The data.table with weight column
#' p99_weight()

p99_weight <- function(switch_data){
  p99 = quantile(switch_data[, weight],
                 prob=c(0.99, 0.1),
                 type = 1)
  len = nrow(switch_data)
  switch_data[weight > p99[1], weight := p99[1]]
  switch_data[weight < p99[2], weight := p99[2]]
  return(switch_data)
}

#' Limit Weights Function
#' 
#' This function truncate the weights using user defined limits
#' @param switch_data The data.table contains weight column
#' @param lower_limit The user defined minimum possible weight
#' @param upper_limit The user defined maximum possible weight
#' limit_weight()

limit_weight <- function(switch_data, lower_limit, upper_limit){
  len = nrow(switch_data)
  switch_data[weight > upper_limit, weight := upper_limit]
  switch_data[weight < lower_limit, weight := lower_limit]
  return(switch_data)
}

#' Weight Logistic Regression Function
#' 
#' This function get the information needed for performing Logistic Regression in the weight calculation process using parglm
#' @param l A list contains the data, logistic regression formula and name of the categorical variables
#' weight_lr()

weight_lr <- function(l){
  d = l[[1]]
  regf = l[[2]]
  class_var = l[[3]]
  
  if(any(!is.na(class_var))){
    for(i in 1:length(class_var)){
      x = factor(d[[eval(class_var[i])]])
      x = relevel(x, ref="1")
      d[, c(eval(class_var[i])) := NULL]
      d[, eval(class_var[i]) := x]
    }
  }
  
  model = parglm::parglm(as.formula(regf), data=d,
                         family = binomial(link = "logit"),
                         control = parglm::parglm.control(nthreads = 4, method='FAST'))
  return(model)
}

#' Case Control Sampling Function
#' 
#' This function apply case control sampling on the extended data
#' @param data A data.table which is the extended version of input data
#' @param n_control Number of controls in the case control sampling Defaults to 5
#' case_control_func()

case_control_func <- function(data, n_control=5){
  ### cases occurred at each period and follow-up visit
  casedatajk<-data[data$outcome==1, ]
  ### controls (still under follow-up and events haven't occurred) at each period and follow-up visit
  controldatajk<-data[data$outcome==0, ]
  dataall = NULL
  ncase<-dim(casedatajk)[1]  ## number of cases
  ncontrol<-dim(controldatajk)[1]  ## number of potential controls
  
  n_control<-min(n_control, ncontrol)
  if(ncase>0){
    if(ncontrol>n_control*ncase){
      ## only sample control when the pool is large enough, otherwise all available control are included
      controlselect<-controldatajk[sample(1:ncontrol, n_control*ncase),]  ## sample 5 controls for each case without replacement
      dataall<-rbind(casedatajk, controlselect)## append sampled data
    }else{
      dataall<-rbind(casedatajk, controldatajk)  
    }
  }
  return(dataall)
}

#' Logistic Regression Function
#' 
#' This function get the information needed for performing Logistic Regression for final model
#' @param l A list contains the data with categorical feature determind if needed and logistic regression formula
#' lr()

lr <- function(l){
  d = l[[1]]
  regf = l[[2]]
  
  model = parglm(as.formula(regf), data=d,
                 weights=d[, weight],
                 family = binomial(link = "logit"),
                 control = parglm.control(nthreads = 4, method='FAST'))
  
  out = robust_calculation(model, d[, id])
  
  return(list(model=model,
              output=out))
}

#' Robust Calculation Funstion
#' 
#' This function performs the calculation with Robust Standard Errors
#' @param model The Logistic Regression model 
#' @param data_id Values of column id of the data (data[, id])
#' robust_calculation()

robust_calculation <- function(model, data_id){
  est_temp = model$coefficients
  v = vcovCL(model, cluster = data_id,
             type = NULL, sandwich = TRUE, fix = FALSE)
  #v = cluster.vcov(model.full, cluster=temp_data[, id], parallel=4)
  se = sqrt(diag(v))
  print("-------------------------------------------------------")
  print("Robust standard error:")
  print(se)
  avg = rbind(est_temp, se)
  output = t(avg)
  output = data.table(output)
  names(output)[names(output) == "est_temp"] <- "estimate"
  names(output)[names(output) == "se"] <- "std"
  output[, name := names(model$coefficients)]
  
  output[, lb := estimate - (1.96 * std)]
  output[, ub := estimate + (1.96 * std)]
  output[, z := estimate/std]
  output[, p_value := format.pval(2*(1-pnorm(abs(z))), eps=0.001)]
  return(output)
}